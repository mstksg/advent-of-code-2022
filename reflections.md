Reflections
===========

<!--
This file generated by the build script at ./Build.hs from the files in
./reflections.  If you want to edit this, edit those instead!
-->

*[2016][]* / *[2017][]* / *[2018][]* / *[2019][]* / *[2020][]* / *[2021][]*

[2016]: https://github.com/mstksg/advent-of-code-2016/blob/master/reflections.md
[2017]: https://github.com/mstksg/advent-of-code-2017/blob/master/reflections.md
[2018]: https://github.com/mstksg/advent-of-code-2018/blob/master/reflections.md
[2019]: https://github.com/mstksg/advent-of-code-2019/blob/master/reflections.md
[2020]: https://github.com/mstksg/advent-of-code-2020/blob/master/reflections.md
[2021]: https://github.com/mstksg/advent-of-code-2021/blob/master/reflections.md

[Available as an RSS Feed][rss]

[rss]: http://feeds.feedburner.com/jle-advent-of-code-2022

Table of Contents
-----------------

* [Day 1](#day-1)
* [Day 2](#day-2)
* [Day 3](#day-3)
* [Day 4](#day-4)
* [Day 5](#day-5) *(no reflection yet)*
* [Day 6](#day-6)
* [Day 7](#day-7) *(no reflection yet)*

Day 1
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day01.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d01p]* / *[Code][d01g]* / *[Rendered][d01h]* / *[Standalone Reflection Page][d01r]*

[d01p]: https://adventofcode.com/2022/day/1
[d01g]: https://github.com/mstksg/advent-of-code-2022/blob/main/src/AOC/Challenge/Day01.hs
[d01h]: https://mstksg.github.io/advent-of-code-2022/src/AOC.Challenge.Day01.html
[d01r]: https://github.com/mstksg/advent-of-code-2022/blob/main/reflections-out/day01.md

Day 1's are usually pretty good for Haskell's stream processing, and this is no
exception :)

To get the list of elf calories, we split on the double newlines, and take the
sum of the lines of each group.

```haskell
import Data.List.Split (splitOn)

getCalories :: String -> [Int]
getCalories = map (sum . map read . lines) . splitOn "\n\n"
```

For part 1, this involves just finding the maximum.

```haskell
part1 :: String -> Int
part1 = maximum . getCalories
```

For part 2, we find the sum of the top 3 values:

```haskell
part2 :: String -> Int
part2 = sum . take 3 . reverse . sort . getCalories
```


### Day 1 Benchmarks

```
>> Day 01a
benchmarking...
time                 118.2 μs   (114.1 μs .. 123.5 μs)
                     0.984 R²   (0.973 R² .. 0.990 R²)
mean                 114.8 μs   (110.9 μs .. 122.2 μs)
std dev              18.66 μs   (10.65 μs .. 35.57 μs)
variance introduced by outliers: 93% (severely inflated)

* parsing and formatting times excluded

>> Day 01b
benchmarking...
time                 230.3 μs   (220.7 μs .. 243.6 μs)
                     0.975 R²   (0.966 R² .. 0.986 R²)
mean                 263.8 μs   (251.5 μs .. 279.3 μs)
std dev              47.28 μs   (36.51 μs .. 56.97 μs)
variance introduced by outliers: 92% (severely inflated)

* parsing and formatting times excluded
```



Day 2
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day02.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d02p]* / *[Code][d02g]* / *[Rendered][d02h]* / *[Standalone Reflection Page][d02r]*

[d02p]: https://adventofcode.com/2022/day/2
[d02g]: https://github.com/mstksg/advent-of-code-2022/blob/main/src/AOC/Challenge/Day02.hs
[d02h]: https://mstksg.github.io/advent-of-code-2022/src/AOC.Challenge.Day02.html
[d02r]: https://github.com/mstksg/advent-of-code-2022/blob/main/reflections-out/day02.md

There's a nice straightforward way to do this by just matching up all 9
combinations, but I had a bit of fun doing it algebraically using `Finite 3`, a
Haskell type that does arithmetic modulo 3, if you assume ABC and XYZ
correspond to 012, respectively.

Basically both parts 1 and 2 involve doing some modular arithmetic to get the
"shape" score, and then some modular arithmetic to get the "outcome" score.

```haskell
type Z3 = Finite 3

play
    :: (Z3 -> Z3 -> Z3)  -- ^ Get shape score
    -> (Z3 -> Z3 -> Z3)  -- ^ Get outcome score
    -> [(Z3, Z3)]
    -> Integer
play shapeScore outcomeScore = sum . map go
  where
    go (x, y) = getFinite (shapeScore x y) + 1
              + getFinite (outcomeScore x y) * 3
```

There is a bit of cute symmetry between `shapeScore` and `outcomeScore` for the
two parts.

```haskell
part1, part2 :: [(Z3, Z3)] -> Integer
part1 = play (\_ y -> y)           (\x y -> y + (1 - x))
part2 = play (\x y -> y - (1 - x)) (\_ y -> y)
```

I mostly just figured it out by using trial and error and taking advantage of
the fact that there are only so many ways you can combine two modulo 3
numbers...but there might be some nice ways to interpret them.

For example, it makes sense that the "shape score" for part 1 is literally just
your shape `y`, and the "outcome score" for part 2 is literally just your
desired outcome `y`

For the outcome score, if you assume that the answer is a "subtraction plus an
offset", then that forces the offset to be 1 in order for a match to represent
a tie.  And so for part 1, the outcome score is found by adding `1-x` to the
shape `y` in order to get the outcome.  So it makes sense that you reverse
the process for part 2: you subtract `1-x` to the outcome `y` in order to get
the shape.  I guess ???


### Day 2 Benchmarks

```
>> Day 02a
benchmarking...
time                 346.2 μs   (339.3 μs .. 355.3 μs)
                     0.992 R²   (0.983 R² .. 0.997 R²)
mean                 355.9 μs   (346.8 μs .. 371.2 μs)
std dev              38.09 μs   (21.64 μs .. 62.81 μs)
variance introduced by outliers: 80% (severely inflated)

* parsing and formatting times excluded

>> Day 02b
benchmarking...
time                 529.4 μs   (515.9 μs .. 542.6 μs)
                     0.993 R²   (0.989 R² .. 0.996 R²)
mean                 524.0 μs   (513.0 μs .. 536.6 μs)
std dev              39.80 μs   (34.98 μs .. 47.59 μs)
variance introduced by outliers: 65% (severely inflated)

* parsing and formatting times excluded
```



Day 3
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day03.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d03p]* / *[Code][d03g]* / *[Rendered][d03h]* / *[Standalone Reflection Page][d03r]*

[d03p]: https://adventofcode.com/2022/day/3
[d03g]: https://github.com/mstksg/advent-of-code-2022/blob/main/src/AOC/Challenge/Day03.hs
[d03h]: https://mstksg.github.io/advent-of-code-2022/src/AOC.Challenge.Day03.html
[d03r]: https://github.com/mstksg/advent-of-code-2022/blob/main/reflections-out/day03.md

Some more "string" processing!  First, let's assume that we receive a list of
priority sequences instead of a list of character strings.  Both of these parts
are actually the same problem, the only difference is how we get our groups.
Once we get the groups, we can convert each string into an `IntSet` and find
the mutual intersection between all of the groups with `IS.intersection` and
`foldl1`:

```haskell
import qualified Data.IntSet as IS

solve :: [[Int]] -> Int
solve = sum . map go
  where
    getPriority = IS.findMin . foldl1 IS.intersection . map IS.fromList
```

Then each part is just finding the right splitting function:

```haskell
part1, part2 :: [Int] -> Int
part1 = solve . map (\xs -> chunksOf (length xs `div` 2) xs)
part2 = solve . chunksOf 3
```


### Day 3 Benchmarks

```
>> Day 03a
benchmarking...
time                 2.280 ms   (2.143 ms .. 2.436 ms)
                     0.977 R²   (0.958 R² .. 0.995 R²)
mean                 2.239 ms   (2.190 ms .. 2.306 ms)
std dev              186.9 μs   (142.5 μs .. 282.1 μs)
variance introduced by outliers: 59% (severely inflated)

* parsing and formatting times excluded

>> Day 03b
benchmarking...
time                 1.676 ms   (1.586 ms .. 1.780 ms)
                     0.978 R²   (0.967 R² .. 0.988 R²)
mean                 1.565 ms   (1.513 ms .. 1.634 ms)
std dev              191.5 μs   (162.9 μs .. 250.2 μs)
variance introduced by outliers: 78% (severely inflated)

* parsing and formatting times excluded
```



Day 4
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day04.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d04p]* / *[Code][d04g]* / *[Rendered][d04h]* / *[Standalone Reflection Page][d04r]*

[d04p]: https://adventofcode.com/2022/day/4
[d04g]: https://github.com/mstksg/advent-of-code-2022/blob/main/src/AOC/Challenge/Day04.hs
[d04h]: https://mstksg.github.io/advent-of-code-2022/src/AOC.Challenge.Day04.html
[d04r]: https://github.com/mstksg/advent-of-code-2022/blob/main/reflections-out/day04.md

A bit of fun number crunching :)  Here is a chance to leverage an interval
library, like haskell's
*[data-interval](https://hackage.haskell.org/package/data-interval)*:

```haskell
import           Data.IntegerInterval (IntegerInterval)
import qualified Data.IntegerInterval as I

part1Criterion :: IntegerInterval -> IntegerInterval -> Bool
part1Criterion xs ys = xs `I.isSubsetOf` ys || ys `I.isSubsetOf` xs

part2Criterion :: IntegerInterval -> IntegerInterval -> Bool
part2Criterion = (I.==?)
```

From there on it's just a matter of running the criteria on each pair of
intervals in the list and counting which ones are valid!


### Day 4 Benchmarks

```
>> Day 04a
benchmarking...
time                 23.44 μs   (23.10 μs .. 23.82 μs)
                     0.999 R²   (0.998 R² .. 1.000 R²)
mean                 23.24 μs   (23.16 μs .. 23.43 μs)
std dev              404.9 ns   (219.1 ns .. 761.3 ns)
variance introduced by outliers: 14% (moderately inflated)

* parsing and formatting times excluded

>> Day 04b
benchmarking...
time                 56.35 μs   (54.69 μs .. 57.86 μs)
                     0.994 R²   (0.991 R² .. 0.998 R²)
mean                 55.18 μs   (54.13 μs .. 56.75 μs)
std dev              4.232 μs   (3.144 μs .. 6.017 μs)
variance introduced by outliers: 74% (severely inflated)

* parsing and formatting times excluded
```



Day 5
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day05.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d05p]* / *[Code][d05g]* / *[Rendered][d05h]* / *[Standalone Reflection Page][d05r]*

[d05p]: https://adventofcode.com/2022/day/5
[d05g]: https://github.com/mstksg/advent-of-code-2022/blob/main/src/AOC/Challenge/Day05.hs
[d05h]: https://mstksg.github.io/advent-of-code-2022/src/AOC.Challenge.Day05.html
[d05r]: https://github.com/mstksg/advent-of-code-2022/blob/main/reflections-out/day05.md

*Reflection not yet written -- please check back later!*

### Day 5 Benchmarks

```
>> Day 05a
benchmarking...
time                 328.8 μs   (321.6 μs .. 337.5 μs)
                     0.995 R²   (0.993 R² .. 0.998 R²)
mean                 332.9 μs   (327.8 μs .. 341.7 μs)
std dev              25.87 μs   (20.10 μs .. 33.16 μs)
variance introduced by outliers: 68% (severely inflated)

* parsing and formatting times excluded

>> Day 05b
benchmarking...
time                 747.5 μs   (738.2 μs .. 757.8 μs)
                     0.998 R²   (0.997 R² .. 0.999 R²)
mean                 751.1 μs   (743.2 μs .. 757.9 μs)
std dev              26.50 μs   (21.01 μs .. 31.93 μs)
variance introduced by outliers: 26% (moderately inflated)

* parsing and formatting times excluded
```



Day 6
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day06.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d06p]* / *[Code][d06g]* / *[Rendered][d06h]* / *[Standalone Reflection Page][d06r]*

[d06p]: https://adventofcode.com/2022/day/6
[d06g]: https://github.com/mstksg/advent-of-code-2022/blob/main/src/AOC/Challenge/Day06.hs
[d06h]: https://mstksg.github.io/advent-of-code-2022/src/AOC.Challenge.Day06.html
[d06r]: https://github.com/mstksg/advent-of-code-2022/blob/main/reflections-out/day06.md

This is a good opportunity to use the ol' sliding windows trick in Haskell list
processing!

Basically if you want sliding windows over a list `"abcdefg"` to get, ie,
`["abc","bcd","cde","def","efg"]`, one thing you can do is iteratively drop items:

```haskell
map (`drop` "abcdefg")  [0,1,2]
-- ["abcdefg","bcdefg","cdefg","defg"]
```

and then take the transpose:

```
transpose $ map (`drop` "abcdefg")  [0,1,2]
-- ["abc","bcd","cde","def","efg","fg","g"]
```

You get the sliding windows, plus a few trailing elements as the window slides
off the edge of the list.

Now at this point we just need to find the first unique sliding window:

```haskell
windows :: Int -> [a] -> [[a]]
windows n xs = transpose $ map (`drop` xs) [0..n-1]

solve :: Int -> String -> Int
solve n xs = find isUnique ws + n
  where
    ws = windows n xs
    isUnique w = S.size (S.fromList w) == n


part1, part2 :: String -> Int
part1 = solve 4
part2 = solve 14
```


### Day 6 Benchmarks

```
>> Day 06a
benchmarking...
time                 990.1 μs   (892.3 μs .. 1.094 ms)
                     0.908 R²   (0.855 R² .. 0.957 R²)
mean                 1.154 ms   (1.084 ms .. 1.283 ms)
std dev              322.4 μs   (238.4 μs .. 450.0 μs)
variance introduced by outliers: 95% (severely inflated)

* parsing and formatting times excluded

>> Day 06b
benchmarking...
time                 1.743 ms   (1.545 ms .. 1.931 ms)
                     0.936 R²   (0.916 R² .. 0.963 R²)
mean                 1.629 ms   (1.551 ms .. 1.779 ms)
std dev              325.9 μs   (253.0 μs .. 442.0 μs)
variance introduced by outliers: 91% (severely inflated)

* parsing and formatting times excluded
```



Day 7
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day07.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d07p]* / *[Code][d07g]* / *[Rendered][d07h]* / *[Standalone Reflection Page][d07r]*

[d07p]: https://adventofcode.com/2022/day/7
[d07g]: https://github.com/mstksg/advent-of-code-2022/blob/main/src/AOC/Challenge/Day07.hs
[d07h]: https://mstksg.github.io/advent-of-code-2022/src/AOC.Challenge.Day07.html
[d07r]: https://github.com/mstksg/advent-of-code-2022/blob/main/reflections-out/day07.md

*Reflection not yet written -- please check back later!*

### Day 7 Benchmarks

```
>> Day 07a
benchmarking...
time                 880.2 μs   (867.4 μs .. 892.5 μs)
                     0.994 R²   (0.988 R² .. 0.998 R²)
mean                 930.2 μs   (912.4 μs .. 966.2 μs)
std dev              88.82 μs   (66.94 μs .. 129.2 μs)
variance introduced by outliers: 71% (severely inflated)

* parsing and formatting times excluded

>> Day 07b
benchmarking...
time                 1.041 ms   (962.4 μs .. 1.115 ms)
                     0.901 R²   (0.810 R² .. 0.978 R²)
mean                 1.273 ms   (1.067 ms .. 1.712 ms)
std dev              927.0 μs   (301.2 μs .. 1.664 ms)
variance introduced by outliers: 98% (severely inflated)

* parsing and formatting times excluded
```

